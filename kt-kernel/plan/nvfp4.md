avx512 实施的 plan
如何使用 cpu 指令查表实现 nvfp4 乘法

首先 一个 group 是 16 个 fp4， 一个 group 的两个 quants 对应相乘，它们会变成一个 byte。512 寄存器有 64byte，因此一次乘法可以做 4 个 group。
假设矩阵乘法是 A x W，即 activation 在左边，activation 的形状是 （qlen， H），Weight的形状是 （H，d）。


fp4 的乘法结果使用 int16 计算，所以有一个表。由于 fp4 的 8 种值是 0 0.5 1 1.5 2 3 4 6，所以最小的分位是 0.25，因此 int16 使用 x4 的方式来保存。
  | ×   | 0   | 0.5  | 1   | 1.5  | 2   | 3   | 4   | 6   |
  |-----|-----|------|-----|------|-----|-----|-----|-----|
  | 0   | 0   | 0    | 0   | 0    | 0   | 0   | 0   | 0   |
  | 0.5 | -   | 0.25 | 0.5 | 0.75 | 1   | 1.5 | 2   | 3   |
  | 1   | -   | -    | 1   | 1.5  | 2   | 3   | 4   | 6   |
  | 1.5 | -   | -    | -   | 2.25 | 3   | 4.5 | 6   | 9   |
  | 2   | -   | -    | -   | -    | 4   | 6   | 8   | 12  |
  | 3   | -   | -    | -   | -    | -   | 9   | 12  | 18  |
  | 4   | -   | -    | -   | -    | -   | -   | 16  | 24  |
  | 6   | -   | -    | -   | -    | -   | -   | -   | 36  |

  去重后的唯一值：

  0, 0.25, 0.5, 0.75, 1, 1.5, 2, 2.25, 3, 4, 4.5, 6, 8, 9, 12, 16, 18, 24, 36
  
  总共 19 种
如果算上负值，有 19x2-1 = 37 种。
_mm512_permutexvar_epi8 可以根据 后 6 位做查表，所以是可以覆盖的。

首先不管做乘法的 fp4 是不是一个 group，集齐 64 对fp4 形成一个 avx512 寄存器。
因此查表部分是这样，先 or 符号位。然后组合尾数和指数，总共 6bit，使用一次 _mm512_permutexvar_epi8 ，查到对应的 19 种结果的序号，这个 19 种只会占 5 bit，然后把符号位放在第 6 个 bit。到这时，还是一个 avx512 寄存器。

然后运行两次 _mm512_permutexvar_epi8， 从 int16 对应的值取出来hi 和 lo。得到两个 avx512 寄存器，然后通过 shuffle 的方式获取 两个 avx512 寄存器，存储 16 个 int16。

现在在于如何选取哪些 fp4。一个自然的想法是一个 Activation 的 group 和 4 个 weight 的 group做乘积。但是这样的代价是需要做 16 个 int16 的 reduce sum。
另外一个想法是一个 Activation 的 fp4 和 64 列的 weight 的fp4 做乘积，好处是 group 的 sum 可以均摊。

假设有 A 出 a 个 element。avx512 总共有 64byte，那么对应 64/a 这么多列的 weight，出对应的 a 个 element。最后有 64/a 个 int16 的求和，然后 64/a 个 f32 的求和。 按 f32 算，avx512 有 16 个，所以看起来可能a = 4是比较好的。一个 group 的 fp4 的排布肯定是对应的，所以 fp4 的总共 byte 数量是 8 个，4 个算的话，可以先取前 4 个高位，然后前 4 个低位，然后后 4 个高位，后 4 个低位。

计算完之后从 int16 转换成 f32，然后乘上 scale，然后累加。
